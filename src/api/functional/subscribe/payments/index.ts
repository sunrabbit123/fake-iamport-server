/**
 * @packageDocumentation
 * @module api.functional.subscribe.payments
 * @nestia Generated by Nestia - https://github.com/samchon/nestia 
 */
//================================================================
import { Fetcher } from "@nestia/fetcher";
import type { IConnection, Primitive } from "@nestia/fetcher";
import typia from "typia";

import { NestiaSimulator } from "./../../../utils/NestiaSimulator";
import type { IIamportSubscription } from "./../../../structures/IIamportSubscription";
import type { IIamportResponse } from "./../../../structures/IIamportResponse";
import type { IIamportCardPayment } from "./../../../structures/IIamportCardPayment";

/**
 * 카드로 결제하기, 더불어 간편 결제용으로 등록 가능.
 * 
 * `subscribe.payments.onetime` 은 카드를 매개로 한 결제를 하고자 할 때 호출하는 API
 * 함수이다. 더하여 입력 값에 {@link IIamportSubscription.IOnetime.customer_uid} 를
 * 기입하는 경우, 결제에 사용한 카드를 그대로 간편 결제용 카드
 * {@link IIamportSubscription} 로 등록해버린다.
 * 
 * 다만, 정히 간편 카드 등록과 결제를 동시에 하고 싶다면,
 * `subscribe.payments.onetime` 에 {@link IIamportSubscription.IOnetime.customer_uid}
 * 를 더하기보다, {@link subscribe.customers.store} 와 {@link subscribe.payments.again}
 * 을 각각 호출하는 것을 권장한다. 그것이 예외적인 상황에 보다 안전하게 대처할 수 있기
 * 때문이다.
 * 
 * 더하여 `subscribe.payments.onetime` 은 클라이언트 어플리케이션이 아임포트가 제공하는
 * 결제 창을 그대로 사용하는 경우, 귀하의 백엔드 서버가 이를 실 서비스에서 호출하는 일은
 * 없을 것이다. 다만, 고객이 카드를 통하여 결제하는 상황을 시뮬레이션하기 위하여, 테스트
 * 자동화 프로그램 수준에서 사용될 수는 있다.
 * 
 * @param input 카드 결제 신청 정보
 * @returns 카드 결제 정보
 * 
 * @author Jeongho Nam - https://github.com/samchon
 * 
 * @controller FakeIampotSubscribePaymentsController.onetime()
 * @path POST /subscribe/payments/onetime
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function onetime(
    connection: IConnection,
    input: onetime.Input,
): Promise<onetime.Output> {
    return !!(connection.simulate ?? (connection as any).random)
        ? onetime.simulate(
              connection,
              input,
          )
        : Fetcher.fetch(
              connection,
              onetime.ENCRYPTED,
              onetime.METHOD,
              onetime.path(),
              input,
          );
}
export namespace onetime {
    export type Input = Primitive<IIamportSubscription.IOnetime>;
    export type Output = Primitive<IIamportResponse<IIamportCardPayment>>;

    export const METHOD = "POST" as const;
    export const PATH: string = "/subscribe/payments/onetime";
    export const ENCRYPTED: Fetcher.IEncrypted = {
        request: false,
        response: false,
    };

    export const path = (): string => {
        return `/subscribe/payments/onetime`;
    }
    export const random = (g?: Partial<typia.IRandomGenerator>): Output =>
        typia.random<Output>(g);
    export const simulate = async (
        connection: IConnection,
        input: onetime.Input,
    ): Promise<Output> => {
        const assert = NestiaSimulator.assert({
            method: METHOD,
            host: connection.host,
            path: path()
        });
        assert.body(() => typia.assert(input));
        return random(
            typeof (connection.simulate ?? (connection as any).random) === 'object'
            && (connection.simulate ?? (connection as any).random) !== null
                ? (connection.simulate ?? (connection as any).random)
                : undefined
        );
    }
}

/**
 * 간편 결제에 등록된 카드로 결제하기.
 * 
 * `subscribe.payments.again` 은 고객이 간편 결제에 등록한 카드로 결제를 진행하고자 할 때
 * 호출하는 API 함수이다. 이는 간편하고 불편하고를 떠나, 본질적으로 카드 결제의 일환이기에,
 * 리턴값은 일반적인 카드 결제 때와 동일한 {@link IIamportCardPayment} 이다.
 * 
 * 그리고 `subscribe.payments.again` 은 결제 수단 중 유일하게, 클라이언트 어플리케이션이
 * 아임포트가 제공하는 결체 창을 사용할 수 없어, 오직 귀하의 백엔드 서버가 아임포트의 API
 * 함수를 직접 호출해야하는 경우에 해당한다. 따라서 간편 결제에 관하여 아임포트 서버와
 * 연동하는 백엔드 서버 및 프론트 어플리케이션을 개발할 때, 반드시 이 상황에 대한 별도의
 * 설계 및 개발이 필요하니, 이 점을 염두에 두기 바란다.
 * 
 * @param input 미리 등록한 카드를 이용한 결제 신청 정보
 * @returns 카드 결제 정보
 * 
 * @author Jeongho Nam - https://github.com/samchon
 * 
 * @controller FakeIampotSubscribePaymentsController.again()
 * @path POST /subscribe/payments/again
 * @nestia Generated by Nestia - https://github.com/samchon/nestia
 */
export async function again(
    connection: IConnection,
    input: again.Input,
): Promise<again.Output> {
    return !!(connection.simulate ?? (connection as any).random)
        ? again.simulate(
              connection,
              input,
          )
        : Fetcher.fetch(
              connection,
              again.ENCRYPTED,
              again.METHOD,
              again.path(),
              input,
          );
}
export namespace again {
    export type Input = Primitive<IIamportSubscription.IAgain>;
    export type Output = Primitive<IIamportResponse<IIamportCardPayment>>;

    export const METHOD = "POST" as const;
    export const PATH: string = "/subscribe/payments/again";
    export const ENCRYPTED: Fetcher.IEncrypted = {
        request: false,
        response: false,
    };

    export const path = (): string => {
        return `/subscribe/payments/again`;
    }
    export const random = (g?: Partial<typia.IRandomGenerator>): Output =>
        typia.random<Output>(g);
    export const simulate = async (
        connection: IConnection,
        input: again.Input,
    ): Promise<Output> => {
        const assert = NestiaSimulator.assert({
            method: METHOD,
            host: connection.host,
            path: path()
        });
        assert.body(() => typia.assert(input));
        return random(
            typeof (connection.simulate ?? (connection as any).random) === 'object'
            && (connection.simulate ?? (connection as any).random) !== null
                ? (connection.simulate ?? (connection as any).random)
                : undefined
        );
    }
}